<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>LLRB Visualizer — Insert / Delete (Animated)</title>
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
        margin: 0;
        background: #f6f7fb;
        color: #222;
      }
      header {
        padding: 12px 20px;
        background: #1f2937;
        color: #fff;
        display: flex;
        align-items: center;
        gap: 12px;
      }
      header h1 {
        font-size: 16px;
        margin: 0;
      }
      .controls {
        display: flex;
        gap: 14px;
        padding: 12px 20px;
        align-items: center;
      }
      .controls > div {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      input[type="text"] {
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid #ccc;
        width: 130px;
      }
      button {
        padding: 7px 12px;
        border-radius: 6px;
        border: 0;
        background: #2563eb;
        color: #fff;
        cursor: pointer;
      }
      button.danger {
        background: #ef4444;
      }
      #canvasWrap {
        padding: 16px;
      }
      svg {
        width: 100%;
        height: 560px;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
      }
      .log {
        height: 160px;
        overflow: auto;
        background: #0f172a;
        color: #fff;
        padding: 12px;
        border-radius: 8px;
        margin: 12px 20px;
      }
      .legend {
        display: flex;
        gap: 12px;
        align-items: center;
        padding: 0 20px 12px;
      }
      .legend span {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .dot {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        display: inline-block;
      }
      a.ref {
        color: #0ea5e9;
      }
      /* highlight styles */
      .node-circle {
        transition: stroke-width 200ms, r 200ms, opacity 200ms;
      }
      .highlight-visit {
        stroke: #f59e0b;
        stroke-width: 6px;
        filter: drop-shadow(0 0 6px rgba(245, 158, 11, 0.6));
      }
      .highlight-swap {
        stroke: #10b981;
        stroke-width: 6px;
        filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.6));
      }
      .label-small {
        font-size: 12px;
        opacity: 0.85;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>
        LLRB (Left-Leaning Red-Black) — Interaktywny visualizer z animacją
      </h1>
      <small style="opacity: 0.8"
        >Podświetlanie ścieżki przy wstawianiu i zamiany przy usuwaniu</small
      >
    </header>

    <div class="controls">
      <div>
        <label>Wstaw (klucz):</label>
        <input id="addKey" type="text" placeholder="np. A lub 42" />
        <button id="btnAdd">Wstaw</button>
      </div>
      <div>
        <label>Usuń (klucz):</label>
        <input id="delKey" type="text" placeholder="np. O lub 17" />
        <button id="btnDel" class="danger">Usuń</button>
      </div>
      <div>
        <button id="btnClear">Wyczyść drzewo</button>
        <button id="btnResetSample">Przykład: ALGORYTM</button>
        <label class="label-small" style="margin-left: 12px">Szybkość:</label>
        <input id="speedRange" type="range" min="50" max="1200" value="400" />
      </div>
      <div style="margin-left: auto">
        <a class="ref" href="/mnt/data/2008LLRB.pdf" target="_blank"
          >Sedgewick LLRB — referencja (PDF)</a
        >
      </div>
    </div>

    <div id="canvasWrap">
      <svg
        id="treeSvg"
        viewBox="0 0 1000 560"
        preserveAspectRatio="xMidYMid meet"
      ></svg>
    </div>

    <div class="legend">
      <span><i class="dot" style="background: #000"></i> BLACK</span>
      <span><i class="dot" style="background: #b22222"></i> RED</span>
      <span style="margin-left: 12px; opacity: 0.85"
        >Operacje i log (kolejność od góry do dołu):</span
      >
    </div>

    <div class="log" id="logArea"></div>

    <script>
      // --- LLRB with instrumentation for animation ---
      class Node {
        constructor(key, color = "R") {
          this.key = key;
          this.left = null;
          this.right = null;
          this.color = color;
        }
      }
      function isRed(x) {
        return x !== null && x.color === "R";
      }

      // action buffer to animate after operation
      let actions = []; // {type:'visit'|'swap'|'rotate'|'flip'|'final', key:..., key2:...}
      function pushAction(a) {
        actions.push(a);
      }

      function rotateLeft(h) {
        pushAction({ type: "rotate", key: h.key, info: "rotateLeft" });
        const x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        h.color = "R";
        return x;
      }
      function rotateRight(h) {
        pushAction({ type: "rotate", key: h.key, info: "rotateRight" });
        const x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        h.color = "R";
        return x;
      }
      function flipColors(h) {
        pushAction({ type: "flip", key: h.key });
        h.color = h.color === "B" ? "R" : "B";
        if (h.left) h.left.color = h.left.color === "B" ? "R" : "B";
        if (h.right) h.right.color = h.right.color === "B" ? "R" : "B";
      }

      // instrumented insert
      function insert(h, key) {
        if (h === null) {
          pushAction({ type: "visit", key: null, info: "create " + key });
          pushAction({ type: "visit", key: key });
          return new Node(key, "R");
        }
        pushAction({ type: "visit", key: h.key, info: "at" });
        if (compare(key, h.key) < 0) h.left = insert(h.left, key);
        else if (compare(key, h.key) > 0) h.right = insert(h.right, key);
        else {
          pushAction({ type: "visit", key: h.key, info: "exists" });
        }
        if (isRed(h.right) && !isRed(h.left)) h = rotateLeft(h);
        if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
        if (isRed(h.left) && isRed(h.right)) flipColors(h);
        return h;
      }

      // moveRedLeft/Right and helpers instrumented
      function moveRedLeft(h) {
        pushAction({ type: "visit", key: h.key, info: "moveRedLeft" });
        flipColors(h);
        if (h.right && isRed(h.right.left)) {
          h.right = rotateRight(h.right);
          h = rotateLeft(h);
          flipColors(h);
        }
        return h;
      }
      function moveRedRight(h) {
        pushAction({ type: "visit", key: h.key, info: "moveRedRight" });
        flipColors(h);
        if (h.left && isRed(h.left.left)) {
          h = rotateRight(h);
          flipColors(h);
        }
        return h;
      }
      function fixUp(h) {
        if (isRed(h.right)) h = rotateLeft(h);
        if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
        if (isRed(h.left) && isRed(h.right)) flipColors(h);
        return h;
      }
      function deleteMin(h) {
        if (h.left === null) {
          pushAction({ type: "visit", key: h.key, info: "deleteMin leaf" });
          return null;
        }
        if (!isRed(h.left) && !isRed(h.left.left)) {
          h = moveRedLeft(h);
        }
        h.left = deleteMin(h.left);
        return fixUp(h);
      }
      function minNode(h) {
        while (h.left) {
          pushAction({ type: "visit", key: h.key, info: "descendMin" });
          h = h.left;
        }
        pushAction({ type: "visit", key: h.key, info: "minNode" });
        return h;
      }

      function deleteKey(h, key) {
        if (compare(key, h.key) < 0) {
          pushAction({ type: "visit", key: h.key, info: "go left" });
          if (h.left) {
            if (!isRed(h.left) && !isRed(h.left.left)) {
              h = moveRedLeft(h);
            }
            h.left = deleteKey(h.left, key);
          }
        } else {
          pushAction({ type: "visit", key: h.key, info: "go right/handle" });
          if (isRed(h.left)) h = rotateRight(h);
          if (compare(key, h.key) === 0 && h.right === null) {
            pushAction({ type: "swap", key: h.key, info: "delete leaf" });
            return null;
          }
          if (h.right) {
            if (!isRed(h.right) && !isRed(h.right.left)) h = moveRedRight(h);
            if (compare(key, h.key) === 0) {
              const m = minNode(h.right);
              pushAction({
                type: "swap",
                key: h.key,
                key2: m.key,
                info: "replace with succ",
              });
              h.key = m.key;
              h.right = deleteMin(h.right);
            } else {
              h.right = deleteKey(h.right, key);
            }
          }
        }
        return fixUp(h);
      }

      // comparator
      function compare(a, b) {
        const na = Number(a),
          nb = Number(b);
        if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
        return ("" + a).localeCompare("" + b);
      }

      // UI & drawing
      let root = null;
      const svg = document.getElementById("treeSvg");
      const logArea = document.getElementById("logArea");
      const speedRange = document.getElementById("speedRange");
      function log(msg) {
        const t = new Date();
        logArea.innerHTML =
          "[" + t.toLocaleTimeString() + "] " + msg + "\n" + logArea.innerHTML;
      }
      function setRootBlack() {
        if (root && root.color === "R") root.color = "B";
      }

      // compute positions using inorder + depth
      function computePositions() {
        const nodes = [];
        function dfs(n, depth) {
          if (!n) return;
          dfs(n.left, depth + 1);
          nodes.push({ key: n.key, node: n, depth });
          dfs(n.right, depth + 1);
        }
        dfs(root, 0);
        const pos = new Map();
        nodes.forEach((item, i) =>
          pos.set(item.key, { x: 80 + i * 80, y: 60 + item.depth * 110 })
        );
        return pos;
      }

      function redraw(withIds = true) {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        if (!root) return;
        const pos = computePositions(); // draw edges
        function drawEdges(n) {
          if (!n) return;
          const p = pos.get(n.key);
          if (n.left) {
            const c = pos.get(n.left.key);
            drawLine(p.x, p.y, c.x, c.y);
            drawEdges(n.left);
          }
          if (n.right) {
            const c = pos.get(n.right.key);
            drawLine(p.x, p.y, c.x, c.y);
            drawEdges(n.right);
          }
        }
        function drawLine(x1, y1, x2, y2) {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", x1);
          line.setAttribute("y1", y1);
          line.setAttribute("x2", x2);
          line.setAttribute("y2", y2);
          line.setAttribute("stroke", "#666");
          line.setAttribute("stroke-width", 2);
          svg.appendChild(line);
        }
        function drawNodes(n) {
          if (!n) return;
          const p = pos.get(n.key);
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.setAttribute("data-key", n.key);
          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", p.x);
          circle.setAttribute("cy", p.y);
          circle.setAttribute("r", 20);
          circle.setAttribute("class", "node-circle");
          circle.setAttribute("fill", n.color === "B" ? "#000" : "#b22222");
          circle.setAttribute("stroke", "transparent");
          circle.setAttribute("stroke-width", 0);
          g.appendChild(circle);
          const text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          text.setAttribute("x", p.x);
          text.setAttribute("y", p.y + 6);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("font-size", "14");
          text.setAttribute("fill", "#fff");
          text.textContent = n.key;
          g.appendChild(text);
          svg.appendChild(g);
          drawNodes(n.left);
          drawNodes(n.right);
        }
        drawEdges(root);
        drawNodes(root);
      }

      // animation runner
      let animRunning = false;
      async function runActions() {
        if (animRunning) return;
        animRunning = true;
        const delay = () =>
          new Promise((res) =>
            setTimeout(res, Number(speedRange.value) || 400)
          );
        for (const a of actions) {
          if (a.type === "visit") {
            if (a.key) {
              highlightNode(a.key, "visit");
              log("visit " + a.key + (a.info ? " — " + a.info : ""));
            } else {
              log(a.info || "visit null");
            }
            await delay();
            clearHighlights();
          } else if (a.type === "rotate") {
            highlightNode(a.key, "visit");
            log(a.info + " at " + a.key);
            await delay();
            clearHighlights();
          } else if (a.type === "flip") {
            highlightNode(a.key, "visit");
            log("flipColors " + a.key);
            await delay();
            clearHighlights();
          } else if (a.type === "swap") {
            if (a.key2) {
              highlightNode(a.key, "swap");
              highlightNode(a.key2, "swap");
              log(
                "swap " + a.key + " <-> " + a.key2 + " (" + (a.info || "") + ")"
              );
              await delay();
              clearHighlights();
            } else {
              highlightNode(a.key, "swap");
              log(a.info || "swap");
              await delay();
              clearHighlights();
            }
          }
        }
        actions = [];
        animRunning = false;
        redraw();
      }

      function highlightNode(key, mode) {
        // add class to circle in group[data-key=key]
        const g = svg.querySelector('g[data-key="' + key + '"]');
        if (!g) return;
        const c = g.querySelector("circle");
        if (mode === "visit") {
          c.classList.add("highlight-visit");
        } else if (mode === "swap") {
          c.classList.add("highlight-swap");
        }
      }
      function clearHighlights() {
        const circles = svg.querySelectorAll("circle.node-circle, circle");
        circles.forEach((c) => {
          c.classList.remove("highlight-visit");
          c.classList.remove("highlight-swap");
          c.setAttribute("stroke", "transparent");
        });
      }

      // UI hooks
      document.getElementById("btnAdd").addEventListener("click", async () => {
        const key = document.getElementById("addKey").value.trim();
        if (!key) return;
        actions = [];
        root = insert(root, key);
        setRootBlack();
        log("Inserted " + key);
        redraw();
        await runActions();
      });
      document.getElementById("btnDel").addEventListener("click", async () => {
        const key = document.getElementById("delKey").value.trim();
        if (!key) return;
        if (!root) {
          log("Drzewo puste");
          return;
        }
        actions = [];
        root = deleteKey(root, key);
        if (root) root.color = "B";
        log("Delete called for " + key);
        redraw();
        await runActions();
      });
      document.getElementById("btnClear").addEventListener("click", () => {
        root = null;
        log("Tree cleared");
        redraw();
      });
      document
        .getElementById("btnResetSample")
        .addEventListener("click", async () => {
          root = null;
          const sample = "ALGORYTM".split("");
          sample.forEach((k) => (root = insert(root, k)));
          if (root) root.color = "B";
          log("Loaded sample: ALGORYTM");
          redraw();
          await runActions();
        });

      // initial draw
      redraw();
    </script>
  </body>
</html>
